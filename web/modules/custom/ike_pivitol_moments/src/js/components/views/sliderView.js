// Generated by CoffeeScript 1.8.0

/*

VIEW SLIDER
This is a component and as such it has a fair amount of abstraction. It requires arguments to put it in context

Args :
  width : viewport width string (with units) or assign a class with width,
  height : viewport height string (with units) or assign a class with height,
  collection : collection of data,
  viewClass : Class of subview
  viewClassParams : Optional arguments for class
  createAmount : Optional int to define number of pre-created views
  loop : Optional boolean to define whether the slider loops or not
  interval : Optional interval to automatically transition views (miliseconds).
  transitionType : Optional string to specify transitions.Values are "fade", "slide".
  transitionDuration : Duration of the transition in miliseconds
  index : initial index;

Default Backbone view args:
  el : optional el,
  tagName : optional tag name
  className : optional class name
  attributes : optional el attributes
 
Triggers:
  "change:index" -> Index has changed. Params : index (this.index), rawIndex (original index passed to setIndex before validation)
  "change:view" -> View has changed and tween animation is finished (view in is completed). Use to activate things and so on. Param view
 */

(function() {
  define(["jquery", "underscore", "backbone"], function($, _, Backbone) {
    return Backbone.View.extend({
      initialize: function(args) {
        var css;
        this.collection = args.collection;
        this.viewClass = args.viewClass;
        this.viewClassParams = args.viewClassParams || null;
        this.createAmount = args.createAmount || 0;
        this.index = args.index || 0;
        this.loop = (args.loop !== undefined ? args.loop : true);
        this.interval = (args.interval !== undefined ? args.interval : 10000);
        this.transitionType = (args.transitionType !== undefined ? args.transitionType : "slide");
        this.transitionDuration = (args.transitionDuration !== undefined ? args.transitionDuration : 700);
        css = {
          overflow: "hidden",
          position: "relative"
        };
        if (args.width) {
          css["width"] = args.width;
        }
        if (args.height) {
          css["height"] = args.height;
        }
        this.$el.css(css);
        this.collection.on("reset", this._onCollectionReset, this);
        if (this.collection.length) {
          return this._onCollectionReset();
        }
      },
      getIndex: function() {
        return this.index;
      },
      setIndex: function(index) {
        var l;
        if (index === this.index) {
          return;
        }
        l = this.collection.length;
        this.index = (index ? (index >= 0 ? (index < l ? index : (this.loop ? index % l : l - 1)) : (this.loop ? Math.abs(l + index) % l : 0)) : 0);
        return this.trigger("change:index", this.index, index);
      },
      getView: function(index) {
        if (index < this.views.length) {
          return this.views[index];
        } else {
          return null;
        }
      },
      moveTo: function(index, duration) {
        var direction;
        this.setIndex(index);
        if (!this.views) {
          return;
        }
        direction = 0;
        if (this.view) {
          index = _.indexOf(this.views, this.view);
          direction = index - this.index;
          if (this.loop && Math.abs(direction) === this.collection.length - 1) {
            direction /= -(this.collection.length - 1);
          }
          this._tweenOut(this.view, direction, duration);
          this.view.setLoadProgress();
        }
        this.view = this.views[this.index];
        this._tweenIn(this.view, direction, duration);
        if (this._intervalID) {
          return this.play();
        }
      },
      play: function() {
        var self;
        if (this.interval) {
          self = this;
          if (this._intervalID) {
            clearTimeout(this._intervalID);
          }
          return this._intervalID = setTimeout(function() {
            if (self.collection.length) {
              return self.moveTo(self.index + 1);
            }
          }, this.interval);
        }
      },
      stop: function() {
        if (this._intervalID) {
          clearTimeout(this._intervalID);
          return this._intervalID = null;
        }
      },
      createViews: function(collection, amount) {
        var i, max, view, _results;
        this.view = null;
        this.views = [];
        this.$el.empty();
        if (collection.length) {
          max = amount && amount < collection.length ? amount : collection.length;
          i = 0;
          _results = [];
          while (i < max) {
            view = this._addView(collection.models[i]);
            _results.push(i++);
          }
          return _results;
        }
      },
      _onCollectionReset: function() {
        this.createViews(this.collection, this.createAmount);
        return this.moveTo(this.index, 0);
      },
      _addView: function(model) {
        var view;
        view = new this.viewClass(_.extend({
          model: model
        }, this.viewClassParams));
        view.$el.css({
          position: "absolute",
          display: "none"
        });
        this.views.push(view);
        this.$el.append(view.$el);
        return view;
      },
      _tweenIn: function(view, direction, duration) {
        var css1, css2, self;
        direction = (direction > 0 ? 1 : (direction < 0 ? -1 : 0));
        duration = (duration != null ? duration : this.transitionDuration);
        css1 = {
          position: "absolute"
        };
        css2 = {};
        switch (this.transitionType) {
          case "slide":
            css1["left"] = -direction * view.$el.width() + "px";
            css2["left"] = 0;
            break;
          case "fade":
            css1["opacity"] = 0;
            css2["opacity"] = 1;
        }
        self = this;
        return view.$el.show().stop().css(css1).animate(css2, {
          duration: duration,
          complete: function() {
            return self.trigger("change:view", view);
          }
        });
      },
      _tweenOut: function(view, direction, duration) {
        var css1, css2;
        direction = (direction > 0 ? 1 : -1);
        duration = (duration != null ? duration : this.transitionDuration);
        css1 = {
          position: "absolute"
        };
        css2 = {};
        switch (this.transitionType) {
          case "slide":
            css2["left"] = direction * view.$el.width() + "px";
            break;
          case "fade":
            css2["opacity"] = 0;
        }
        return view.$el.stop().css(css1).animate(css2, {
          duration: duration,
          complete: function() {
            return view.$el.hide();
          }
        });
      },
      destroy: function() {
        this.collection.off("reset", this._onCollectionReset, this);
        this.stop();
        if (this.views) {
          _.each(this.views, function(view) {
            if (view.destroy !== undefined) {
              return view.destroy();
            }
          });
        }
        return this.remove();
      }
    });
  });

}).call(this);
